# -*- coding: utf-8 -*-
"""21201128_zannatun_tazree_tisha_A2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xKZIVIJsn2-Uv0nyjIYyAjnHI8IZ-QMc
"""

import random
import math

grid=25
popu_size=6 # Renamed variable to avoid conflict
mut_rate = 0.1
max_gen = 15
A = 1000
B = 2
G = 1
blcs = {"ALU": (5, 5),"Cache": (7, 4),"Control Unit": (4, 4),"Register File": (6, 6),"Decoder": (5, 3),"Floating Unit": (5, 5)}
blc_names = list(blcs.keys())
conn = [("Register File", "ALU"),("Control Unit", "ALU"),("ALU", "Cache"),("Register File", "Floating Unit"),("Cache", "Decoder"),("Decoder", "Floating Unit")]

def gen_ran_chro():
  return [(random.randint(0, grid - blcs[name][0]), random.randint(0, grid - blcs[name][1])) for name in blc_names]

def gen_initi_popu():
  return [gen_ran_chro() for _ in range(popu_size)] # Use popu_size here

def middle(crd, blc_name):
 (x, y)= crd
 (w, h)= blcs[blc_name]
 return (x+w)/2, (y+h)/2

def dist(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def overlapping(a_pos, b_pos, a_sze, b_sze):
 (aw, ah)= a_sze
 (bw, bh)= b_sze
 (ax1, ay1)= a_pos
 (bx1, by1)= b_pos
 (ax2, ay2)= (ax1 + aw), (ay1 + ah)
 (bx2, by2)= (bx1 + bw), (by1 + bh)
 return not (ax2 <= bx1 or ax1 >= bx2 or ay2 <= by1 or ay1 >= by2)

def fitness(k):   ##chromosome=k
  overlaps = 0
  for i in range(len(blc_names)):
    for j in range(i + 1, len(blc_names)):
      if overlapping(k[i], k[j], blcs[blc_names[i]], blcs[blc_names[j]]):
         overlaps += 1

  total_wire = 0
  pos_dict = {blc_names[i]: k[i] for i in range(len(blc_names))}
  for a, b in conn:
    total_wire += dist(middle(pos_dict[a], a), middle(pos_dict[b], b))

  x= [crd[0] for crd in k]
  y= [crd[1] for crd in k]
  x1= [crd[0] + blcs[blc_names[i]][0] for i, crd in enumerate(k)]
  y1= [crd[1] + blcs[blc_names[i]][1] for i, crd in enumerate(k)]
  bounding_area = (max(x1) - min(x)) * (max(y1) - min(y))
  fitness = -(A * overlaps + B * total_wire + G * bounding_area)
  return fitness, overlaps, total_wire, bounding_area

def single_point_crossover(parent1, parent2):
 point = random.randint(1, len(parent1)-2)
 cld1 = parent1[:point] + parent2[point:]
 cld2 = parent2[:point] + parent1[point:]
 return cld1, cld2

def two_point_crossover(parent1, parent2):
  p1 = random.randint(0, len(parent1)-2)
  p2 = random.randint(p1 + 1, len(parent1) - 1)
  cld1 = parent1[:p1] + parent2[p1:p2] + parent1[p2:]
  cld2 = parent2[:p1] + parent1[p1:p2] + parent2[p2:]
  return cld1, cld2

def mutate(k):
 if random.random() < mut_rate:
    i = random.randint(0, len(k)-1)
    w, h = blcs[blc_names[i]]
    new_x = random.randint(0, grid-w)
    new_y = random.randint(0, grid-h)
    k[i] = (new_x, new_y)
 return k

def run_ga(two_point=False):
    popu = gen_initi_popu()
    for i in range(max_gen):
        fitnessp = [fitness(c) for c in popu]
        fit_scrs = [f[0] for f in fitnessp]
        best_idx = fit_scrs.index(max(fit_scrs))
        best_chromosome = popu[best_idx]
        new_popu = [best_chromosome]
        while len(new_popu) < popu_size:
            p1, p2 = random.sample(popu, 2)
            if two_point:
                c1, c2 = two_point_crossover(p1, p2)
            else:
                c1, c2 = single_point_crossover(p1, p2)
            new_popu.extend([mutate(c1), mutate(c2)])

        popu = new_popu[:popu_size]

    final_scr = [fitness(c) for c in popu]
    fitness_vals = [f[0] for f in final_scr]
    best_fit = max(fitness_vals)
    best_idx = fitness_vals.index(best_fit)
    best_layout = popu[best_idx]
    best_fit, overlaps, wire_len, area = final_scr[best_idx]
    return {"layout": best_layout,"fitness": best_fit,"overlaps": overlaps,"wiring": wire_len,"bounding_area": area}

def print_result(task_name, result):
    print(f"\n{task_name}")
    print("Best Layout:")
    for i, crd in enumerate(result["layout"]):
        print(f"{blc_names[i]} â†’ {crd}")
    print(f"\nFitness Score: {result['fitness']:.2f}")
    print(f"Total Overlaps: {result['overlaps']}")
    print(f"Total Wiring Length: {result['wiring']:.2f}")
    print(f"Bounding Box Area: {result['bounding_area']}")


task1= run_ga(two_point=False)
print_result("Task 1 (Single-Point Crossover)", task1)
task2= run_ga(two_point=True)
print_result("Task 2 (Two-Point Crossover)", task2)