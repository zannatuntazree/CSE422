# -*- coding: utf-8 -*-
"""21201128_Zannatun_Tazree_Tisha_A1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DY-eHJWz7fdwa1o5NFMaugrdi7sxAzMz
"""

#part 1
import heapq
def astar(n, m, st, gl, mz):
  def heuris(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])
  dir=[(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')]
  vi = []
  for i in range(n):
    row = []
    for j in range(m):
      row.append(False)
    vi.append(row)
  heap=[]
  heapq.heappush(heap, (0 + heuris(st, gl), 0, st, ""))
  while heap:
    cst, total_cst, (x, y), path = heapq.heappop(heap)
    if (x, y)==gl:
      print(total_cst)
      print(path)
      return
    if vi[x][y]:
      continue
    vi[x][y]=True
    for x1, y1, move in dir:
      nx, ny=(x + x1, y + y1)
      if (0<= nx <n) and (0<= ny <m) and not vi[nx][ny] and mz[nx][ny] == '0':
        heapq.heappush(heap, (total_cst + 1 + heuris((nx, ny), gl), total_cst + 1, (nx, ny), path + move))
  print(-1)

n, m = map(int, input().split())
a, b = map(int, input().split())
c, d = map(int, input().split())
mz = [list(input().strip()) for _ in range(n)]
astar(n, m, (a, b), (c, d), mz)

#part 2
from collections import deque, defaultdict
def bfs(n, gr, gl):
  dist = [float('inf')] * (n + 1)
  dist[gl] = 0
  Q = deque([gl])
  while Q:
    cur=Q.popleft()
    for neibor in gr[cur]:
      if dist[neibor] > dist[cur] + 1:
        dist[neibor] = dist[cur] + 1
        Q.append(neibor)
  return dist

def admissibleity(n, m, st, gl, heuris, eds):
  gr = defaultdict(list)
  for v, u in eds:
    gr[v].append(u)
    gr[u].append(v)
  admisible = []
  inadmisible = []
  shortPath=bfs(n, gr, gl)
  for node in range(1, n + 1):
    if heuris[node] > shortPath[node]:
      inadmisible.append(node)
    else:
      admisible.append(node)
  if not inadmisible:
    print(1)
  else:
    print(0)
    print("inadmisible:" , *inadmisible)

n, m = map(int, input().split())
st, gl = map(int, input().split())
heuris = {}
for i in range(n):
    node, h = map(int, input().split())
    heuris[node] = h
eds = [tuple(map(int, input().split())) for i in range(m)]
admissibleity(n, m, st, gl, heuris, eds)